<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
    <script src='test1.js'></script>

<style> 
.Task {
  /* width: 160px; */
  height: 120px;
  background-color: coral;
  color: white;
}
.access {
  /* width: 50px; */
  height: 50px;
   background-color: rgb(39, 244, 107);
  color: white; 
  display: inline-block;
}
.initialDuration {
    height: 50px;
  background-color: rgb(206, 244, 39);
  color: white;
  display: inline-block;
}

.interferenceDuration {
    height: 50px;
  background-color: rgb(243, 49, 49);
  color: white;
  display: inline-block;
}

.execute {
  /* width: 50px; */
  height: 50px;
  background-color: #6b27f4;
  color: white;
  display: inline-block;
}
</style>
<script src="./node_modules/js-simulator/src/jssim.js" type="text/javascript"></script>
</head>
<body onload="initSimulation()">

<p>Click the "Try it" button to change the width of the DIV element:</p>

<button onclick="startSimulation()">Start</button>
<button onclick="stopSimulation()">Stop</button>


<script>

//   document.getElementById("Task").style.width = "220px";
//   document.getElementById("Exec").style.width = "100px";
//   document.getElementById("Exec").style.background = "linear-gradient(to right, #6b27f4, #FF0000)";


class Resource extends jssim.SimEvent {
    constructor(uid, priority, sched){
        super(priority)
        this.id=uid
        this.state = "idle"
        this.scheduler = sched
    }

    //for record
    resourceStates = ["idle", "inUse"]
    resourceEvents = ["get", "free"]

    //todo add current user id


    //FSM 
    react(content, sender_id){
        if (this.state == "idle"){
            if(content == "get"){
                this.state = "inUse"
                this.sendMsg(sender_id,{
                    content: "OK",
                    sender:this.guid()
                })
            }
            else if(content == "free"){
                console.error("cannot free an idle resource")
                this.scheduler.reset()
            }
        }
        else if (this.state == "inUse"){
            if(content == "get"){
                this.sendMsg(sender_id,{
                    content: "KO",
                    sender:this.guid()
                })
            }
            else if(content == "free"){
                this.state = "idle"
                this.sendMsg(sender_id,{
                    content: "OK",
                    sender:this.guid()
                })
            }
        }
    }

    //timed update
    update(deltaTime){
        // console.log('resource [' + this.id + '] is fired at time ' + this.time+ " deltaTime= "+deltaTime);
        var messages = this.readInBox();
            for(var i = 0; i < messages.length; ++i){
                var msg = messages[i];
                var sender_id = msg.sender;
                var recipient_id = msg.recipient; // should equal to this.guid()
                var time = msg.time;
                var rank = msg.rank; // the messages[0] contains the highest ranked message and last messages contains lowest ranked
                var content = msg.content; // for example the "Hello" text from the sendMsg code above
                this.react(content, sender_id)
                console.log("@"+this.time+" resource "+this.guid()+" is "+this.state)
        }

    }

}



class Task extends jssim.SimEvent {
    constructor(uid, priority, sched, seg){
        super(priority)
        this.id=uid
        this.state = "waitingAction"
        this.segment = seg
        this.currentAction = 0
        this.scheduler = sched
        this.interferenceDuration = 0
        this.startWaitingTime = 0
        this.taskWidth = 0;
        this.initializeDOM(uid, seg)
    }

    initializeDOM(uid, seg) {
        // create a new div element
        const task = document.createElement("div");
        task.className = "Task";
        task.id=uid.toString()
        const title = document.createElement("h1");
        title.appendChild(document.createTextNode(uid.toString()));
        task.appendChild(title);
        // and give it some content
        
        for (var i in seg) {
            var type=seg[i][0];
            var duration = seg[i][1];
            const action = document.createElement("div");
            if (type === "access"){
                const accessInit = document.createElement("div");
                accessInit.className="initialDuration"
                accessInit.style.width = (duration * 10).toString() + "px";
                action.appendChild(accessInit) 
                const accessInterference = document.createElement("div");
                accessInterference.className="interferenceDuration"
                accessInterference.style.width = "0px";
                action.appendChild(accessInterference)   
            }
            action.className = type;
            action.style.width = (duration * 10).toString() + "px";
            this.taskWidth = this.taskWidth + (duration * 10);
            task.appendChild(action);
        }

        task.style.width = (this.taskWidth * 1.1).toString() + "px";

        // add the newly created element and its content into the DOM
        document.body.appendChild(task);
    }

    TaskStates = ["waitingAction", "running", "waitingResource", "accessingResource", "dead"]


    react(deltaTime){
        var nextSched = 0
        var messages = this.readInBox();
        if(this.state == "waitingAction"){
            if (this.segment[this.currentAction][0] == "execute"){
                this.state = "executing"
                nextSched = this.segment[this.currentAction][1]
            }
            else if (this.segment[this.currentAction][0] == "access"){
                this.state = "waitingResource"
                var resource = this.segment[this.currentAction][2]
                this.sendMsg( resource.guid(), {
                    content: "get",
                    sender:this.guid()
                });
                this.scheduler.scheduleOnceIn(resource,0)
            }
        }
        else if(this.state == "executing"){
            this.currentAction = (this.currentAction+1)%this.segment.length
            this.state = "waitingAction"
        }
        else if(this.state == "waitingResource"){
            if(this.startWaitingTime == 0){
                this.startWaitingTime = this.time
            }
            this.interferenceDuration = this.time - this.startWaitingTime
            var taskDiv = document.getElementById(this.guid().toString())
            var accessDiv = taskDiv.childNodes[this.currentAction+1]
            var interferDiv = accessDiv.childNodes[1]
            taskDiv.style.width = (this.taskWidth + this.interferenceDuration).toString()+"px"
            accessDiv.style.width = (this.segment[this.currentAction][1]*10 + this.interferenceDuration).toString()+"px" 
            interferDiv.style.width = this.interferenceDuration.toString()+"px"
            //wait at least one here
            nextSched = 1
            for(var i = 0; i < messages.length; ++i){
                var msg = messages[i];
                var content = msg.content; // for example the "Hello" text from the sendMsg code above
                if (content == "OK"){
                    this.state = "accessingResource"
                    nextSched = this.segment[this.currentAction][1]
                }
                else if (content == "KO"){
                    var resource = this.segment[this.currentAction][2]
                    this.sendMsg( resource, {
                        content: "get",
                        sender:this.guid()
                    });
                    this.scheduler.scheduleOnceIn(resource,0)
                }
            }
        }
        else if(this.state == "accessingResource"){
            this.startWaitingTime = 0
            var resource = this.segment[this.currentAction][2]
            this.sendMsg(resource.guid(), {
                content: "free",
                sender:this.guid()
            });
            this.scheduler.scheduleOnceIn(resource,0)
            this.currentAction = (this.currentAction+1)%this.segment.length
            this.state = "waitingAction"
        }

    return nextSched
    }


    update(deltaTime){
        // console.log('task ' + this.id + '[' + this.rank + ' ] @' + this.time+ " deltaTime= "+deltaTime);
        var nextSched = this.react(deltaTime)
        console.log("@"+this.time+" task "+this.guid()+" is "+this.state)
        this.scheduler.scheduleOnceIn(this,nextSched) 
    }

}
var scheduler = new jssim.Scheduler();

function initSimulation(){
    
    scheduler.reset();
    var r1 = new Resource(69,3, scheduler)

    var t1 = new Task(42, 2, scheduler, [["access", 5, r1], ["execute", 10], ["access", 5, r1]])
    var t2 = new Task(88, 2, scheduler, [["access", 5, r1], ["execute", 10], ["access", 5, r1]])
    
    scheduler.schedule(t1, 0);
    scheduler.schedule(t2, 0);
    scheduler.scheduleRepeatingAt(r1, 0, 1);
}

function startSimulation() {

    // while(scheduler.current_time < 10000) {
    //     if(scheduler.current_time%99 == 0){
    //         setTimeout(()=>{}, 1)
    //     }
    //     scheduler.update();
    // }

    this.intervalID = window.setInterval(()=>{scheduler.update()}, 20);

}

function stopSimulation() {
    window.clearInterval(this.intervalID)
}


</script>


</body>
</html>